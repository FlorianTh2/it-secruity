toBigInt10
	bisher add und alles danach ausgelassen




expand
//    	 setzt die neuen signifikanten Zellen auf 0.
    	 //wurde hier (noch nicht) gemacht


errors:

bei mod und / : ist cell_size richtig oder ... idk

le()


Änderungen:
        	if(a.value[a.spart] != 0), vorher ohne if
        	{
    			resize(a,(short) (a.spart+1));
        	}

    		reduce: a.spart=(short) (i+1);   zu    a.spart=(short) (i);, da nach meiner for-schleife glaube +1 nicht mehr notwendig ist



bemerkungen:
	-to a.spart-1: ist nicht < a.spart-1 sondern: <= a.spart
	-base=2^(maxbitperint) also 111111111111111 (ca 65000)
	-current spart interpretation: pointer zu jener zelle (die leer, also 0 ist), die genau nach dem signifikanten Teil kommt
		- Begründung: er schrieb:
			"Die Routine reduce(ref BigInt x) setzt den Deskriptor spart auf die Länge des signifikanten Teils, der mindestens eine Zelle umfasst."
			"spart ist die Größe des niederwertigen Teils des Arrays mit allen Zellen oberhalb davon gleich 0."
				- Länge/Groesse kann ja nicht 0 sein...
				- länge muss also eig >=1 sein, und kann nicht 0 sein
					- 0 dachte ich evt, da spart dann genau auf den current max index des signifikanten teils zeigt





a[i]:= tmp & mask;
a[i]= (int)(tmp & CELL_MASK);
//over:= (tmp>>base) & mask;
 over= (short)((tmp>>CELL_SIZE) & CELL_MASK);


[1,0]: 65536: 10000000000000000

umrechnung der Ausgabe nach dezimal ("zur richtigen Zahl")
	theorie: komplettes array physikalisch betrachten (so ist es physikalisch gespeichert und gecoded/gedacht) -> array ist also ein polynom und jedes einzelne bit (also Dualsystem) ist ein term, der in das dezimalsystem umgerechnet werden muss: Beispiel: 1102 = 1·2^2 + 1·2^1 + 0·2^0 = 1·2·2 + 1·2 + 0 = (1·2 + 1)·2 + 0 = 610


	schnell zum testen:
		z.B. [4,1]
			für jede Zahl folgendes tuhen und nach gegebener reihenfolge aneinander knüpfen
				- 4 in dual umwandeln -> 100
				- 0len ergänzen bis 16 bit ausgereizt -> 0000000000000100
			die 16bitter aneinander reihen und (per Rechner) nach dezimal umwandeln
				- hier: 00000000000001000000000000000001

		